Structure
=========

Build scripts are located in the root directory, the package source code is in `/src/`, documentation is in `/doc/`, and examples are in `/examples/`.

Documentation
=============

Documentation is generated with Sphinx, by basically following [this tutorial](http://matplotlib.org/sampledoc/). The `build_doc.sh` script can be used to build the documentation automatically.

Uploading the documentation to github ph-pages is done by pulling the gh-pages branch, rsyncing in the newly built documentation from `doc/_build/html/`, then committing the changes. The `upload_doc.sh` script performs these tasks automatically. A related tutorial can be found [here](http://help.github.com/articles/creating-project-pages-manually), but this shouldn't be followed explicitly, because the gh-pages branch already exists.

Git Branching Model
===================
I'm using the Git branching model described [here](http://nvie.com/posts/a-successful-git-branching-model/).

Design
======

Here's the problem: some of the parameters depend on temperature, and some don't. The ones that depend on temperature have to be functions, while the ones that don't are not functions. The user has no clear way of knowing which parameters are functions, and which are not, until an exception is thrown. Should I just make all parameters functions of temperature, even if they aren't really? Or I can make them all functions with keyword arguments, and only use T values if needed (and show in the docstring if it's used). This is probably the cleanest approach.

The next question is how to best store the values. Should they be hardcoded in, with references in comments? This is the most runtime efficient. If I have a separate wiki for maintaining the most up-to-date values, then I could just do periodic releases with the changes from the wiki incorporated by looking at the wiki change history. This would be a fairly manual approach, as apposed to automated. However, in this case I think requiring a human in the loop isn't necessarily a bad thing, since the human can sanity check the changes. Linus still does merges to the Linux kernal by hand.

I need to think throught the API to make sure it's easy to use for the use cases I care most about. Then, and only then, I'll choose the implementation to fit the API. That's right, I'm going to pretend I'm an actual software engineer.

----

Okay, I now have hardcoded values with preceding underscores and functions without preceding underscores. The hardcoded variable names are subject to change if I decide to change the implementation.

Building and Uploading to PyPI
==============================

When a new release is ready, and `version.py` has already been updated, run the following commands from the root of the git repository to build and upload the release to PyPI:

    python setup.py build
    python setup.py register sdist bdist_egg upload

It's also a good idea to update the documentation:

    ./build_doc.sh
    ./upload_doc.sh