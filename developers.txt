Structure
=========

Build scripts are located in the root directory, the package source code is in `/src/` with examples in `src/openbandaprams/examples/` and tests in `/src/openbandarams/tests/`. Documentation is in `/doc/`.

Documentation
=============

Documentation is generated with Sphinx, by basically following [this tutorial](http://matplotlib.org/sampledoc/). The `build_doc.sh` script can be used to build the documentation automatically.

Uploading the documentation to github ph-pages is done by pulling the gh-pages branch, rsyncing in the newly built documentation from `doc/_build/html/`, then committing the changes. The `upload_doc.sh` script performs these tasks automatically. A related tutorial can be found [here](http://help.github.com/articles/creating-project-pages-manually), but this shouldn't be followed explicitly, because the gh-pages branch already exists.

Git Branching Model
===================
I'm using the Git branching model described [here](http://nvie.com/posts/a-successful-git-branching-model/).

Design
======

A somewhat unusual approach was required to get the desired API.

Here's the problem: some of the parameters depend on temperature, and some don't. The ones that depend on temperature have to be functions, while the ones that don't are not functions. The user has no clear way of knowing which parameters are functions, and which are not, until an exception is thrown. I could have either made all parameters functions of temperature, even if they aren't really, or I could make them all functions with keyword arguments, and only use T values if needed (and show in the docstring if it's used). The latter approach is the one I settled on.

The next question was how to best store the parameters. Should they be hardcoded in, with references in comments? This is the most runtime efficient. If I have a separate wiki for maintaining the most up-to-date values, then I could just do periodic releases with the changes from the wiki incorporated by looking at the wiki change history. This would be a fairly manual approach, as apposed to automated. However, in this case I think requiring a human in the loop isn't necessarily a bad thing, since the human can sanity check the changes. Apparently Linus still does merges to the Linux kernal by hand.

It's important that the user interface is easy to understand and use. Ultimately it doesn't matter how complex the implementation is (as long as it works). Thus, I'm designing the interface, and only then figuring out how to implement it.

Building and Uploading to PyPI
==============================

** Note: this section needs revision **

When a new release is ready and merged into the master branch and `version.py` has already been updated, you are almost ready to upload the release to PyPI. You should be on either the develop or release candidate branch. First, you should update the documentation:

    ./build_doc.sh
    ./upload_doc.sh

Then run the following commands from the root of the git repository to build and upload the release to PyPI:

    python setup.py build
    python setup.py register sdist bdist_egg upload