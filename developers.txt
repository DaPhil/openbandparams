Structure
=========

Build scripts are located in the root directory, the package source code is in `/src/`, documentation is in `/doc/`, and examples are in `/examples/`.

Documentation
=============

Documentation is generated with Sphinx, by basically following the [this tutorial](http://matplotlib.org/sampledoc/).

Uploading the documentation to github ph-pages is done by checking out the gh-pages branch, copying in the newly built documentation from `doc/_build/html/`, then committing the changes. A related tutorial can be found [here](http://help.github.com/articles/creating-project-pages-manually), but this shouldn't be followed explicitly, because the gh-pages branch already exists (although it could easily be deleted and remade).

Git Branching Model
===================
I'm using the Git branching model described [here](http://nvie.com/posts/a-successful-git-branching-model/).

Design
======

Here's the problem: some of the parameters depend on temperature, and some don't. The ones that depend on temperature have to be functions, while the ones that don't are not functions. The user has no clear way of knowing which parameters are functions, and which are not, until an exception is thrown. Should I just make all parameters functions of temperature, even if they aren't really? Or I can make them all functions with keyword arguments, and only use T values if needed (and show in the docstring if it's used). This is probably the cleanest approach.

The next question is how to best store the values. Should they be hardcoded in, with references in comments? This is the most runtime efficient. If I have a separate wiki for maintaining the most up-to-date values, then I could just do periodic releases with the changes from the wiki incorporated by looking at the wiki change history. This would be a fairly manual approach, as apposed to automated. However, in this case I think requiring a human in the loop isn't necessarily a bad thing, since the human can sanity check the changes. Linus still does merges to the Linux kernal by hand.

I need to think throught the API to make sure it's easy to use for the use cases I care most about. Then, and only then, I'll choose the implementation to fit the API. That's right, I'm going to pretend I'm an actual software engineer.

----

Okay, I now have hardcoded values with preceding underscores and functions without preceding underscores. The hardcoded variable names are subject to change if I decide to change the implementation.